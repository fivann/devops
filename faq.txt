### в чем разница между Deployments и StatefulSets в k8s?

В Kubernetes и Deployments, и StatefulSets (ранее известные как PetSets) являются контроллерами, которые управляют жизненным циклом pods, 
но между ними есть некоторые ключевые различия.

Deployments предназначены для управления stateless приложениями, 
где каждый экземпляр приложения может заменяться на любой другой экземпляр. 
Deployments гарантируют, что в любой момент времени запущено заданное количество реплик приложения. 
При обновлении Deployment Kubernetes создает новый набор replica pods с обновленной конфигурацией 
и постепенно масштабирует новые pods, снижая старые, пока не будет достигнуто желаемое состояние. 
Deployments хороши для безсостояничных приложений, таких как веб-серверы, где не важно, какой pod обрабатывает данный запрос.

С другой стороны, StatefulSets предназначены для управления stateful приложениями, 
где каждый экземпляр приложения имеет уникальный идентификатор, который необходимо сохранять при обновлениях. 
StatefulSets обеспечивают уникальные и стабильные сетевые идентификаторы для каждого pod, 
что позволяет масштабировать и обновлять состояничные приложения, сохраняя их идентификаторы. 
При обновлении StatefulSet Kubernetes обновляет pods в контролируемом режиме, по одному, чтобы сохранить правильный порядок pods. 
StatefulSets подходят для состояничных приложений, таких как базы данных, где каждый pod должен сохранять свое состояние и уникальный идентификатор.

В целом, хотя Deployments отлично подходят для безсостояничных приложений,
они не подходят для состояничных приложений, которые требуют уникальных идентификаторов и постоянного хранилища. 
В таких случаях StatefulSets являются лучшим выбором, так как они предоставляют больший контроль над порядком и масштабированием pods.

#####

В Kubernetes ReplicaSet и Deployment - это два вида контроллеров развертывания, которые позволяют создавать и управлять репликами подов в кластере.

ReplicaSet - это контроллер, который создает и управляет репликами подов, обеспечивая масштабируемость и отказоустойчивость приложения. 
ReplicaSet следит за количеством запущенных реплик подов и при необходимости создает или удаляет их. Он не позволяет задавать стратегию обновления приложения.

Deployment - это контроллер, который управляет ReplicaSet и позволяет настраивать стратегию обновления приложения. 
Deployment позволяет задавать параметры, такие как максимальное количество недоступных подов во время обновления, 
максимальное количество новых подов, которые могут быть созданы одновременно, и многие другие.

Основная разница между ReplicaSet и Deployment заключается в том, что ReplicaSet отвечает только за масштабирование 
и отказоустойчивость приложения, в то время как Deployment предоставляет более высокоуровневые функции управления 
развертыванием приложения, такие как стратегии обновления и отката. Deployment использует ReplicaSet в качестве 
базовой модели управления репликами подов, которая позволяет масштабировать и управлять доступностью приложения.

###

В Kubernetes DaemonSet и StatefulSet являются двумя различными типами контроллеров развертывания (deployment controllers), 
которые используются для управления подами в кластере.

DaemonSet используется для запуска копии пода на каждом узле кластера. Это полезно, когда требуется запускать 
определенный набор подов на каждом узле, например, для сбора логов или мониторинга хостов. 
Каждый под в DaemonSet работает независимо от других подов в кластере.

StatefulSet, с другой стороны, используется для управления подами, которые имеют уникальные идентификаторы
и живут в течение всего жизненного цикла приложения, то есть не могут быть легко заменены новыми версиями. 
Это полезно, когда требуется управлять состоянием приложения, таким как база данных или кэш, 
которые должны сохранять свое состояние между перезапусками.

В StatefulSet каждый под имеет уникальное имя, которое сохраняется между перезапусками, и сетевой идентификатор, 
который гарантирует уникальность пода в сети. Это позволяет подам в StatefulSet сохранять свое состояние между 
перезапусками и обеспечивает возможность горизонтального масштабирования и управления состоянием приложения.



### в чем разница между cmd и enterypoint в Dockerfile и для чего нужны квадратные скобки в этих командах. Какой enterypoint по умолчанию?

В Dockerfile команды CMD и ENTRYPOINT определяют, какой исполняемый файл или команда должны быть запущены, когда контейнер стартует.

Основная разница между CMD и ENTRYPOINT заключается в том, что CMD предоставляет аргументы, 
которые могут быть переопределены при запуске контейнера, в то время как ENTRYPOINT определяет исполняемый файл или команду, 
которые запускаются в контейнере и не могут быть переопределены.

Команда CMD позволяет определить значения по умолчанию для команды, которая будет выполнена в контейнере, 
если при запуске контейнера не были указаны другие команды. Команда ENTRYPOINT определяет исполняемый файл, 
который будет выполнен в контейнере.

Квадратные скобки в командах CMD и ENTRYPOINT обозначают необязательные аргументы. Внутри скобок можно 
указать значение по умолчанию для аргумента. Например, команда CMD ["executable", "arg1", "arg2"] означает, 
что по умолчанию контейнер будет запущен с командой "executable arg1 arg2", но если при запуске контейнера
будут указаны другие аргументы, они заменят значения по умолчанию.

Если в Dockerfile не указана команда ENTRYPOINT, по умолчанию используется команда /bin/sh -c. 
Если не указана команда CMD, то по умолчанию используется пустая команда.

### В чем разница запуска команды с квадратными скобками и без них? Как это влияет на PID?
В Dockerfile квадратные скобки используются для определения команды или аргументов в формате массива JSON. 
Команда или аргументы, определенные внутри квадратных скобок, будут рассматриваться как единое целое и будут переданы Docker при запуске контейнера.

Когда команда или аргументы не заключены в квадратные скобки, они будут рассматриваться как строка, 
и Docker попытается интерпретировать их как команду для запуска в контейнере. 
Это может привести к тому, что внутри команды будут разобраны все аргументы и выполнены как отдельные команды, 
что может привести к неожиданным результатам.

Касательно PID, разницы между запуском команды с квадратными скобками и без них нет. 
PID - это уникальный идентификатор процесса, который запущен в контейнере. 
Он будет назначен для процесса независимо от того, была ли команда запущена с использованием квадратных скобок или без них. 
Однако, используя квадратные скобки, можно избежать нежелательных ошибок при запуске команды в контейнере 
и получить более точный контроль над тем, какие аргументы будут переданы при запуске команды.

### Рассмотрим пример команды, которая запускает скрипт с аргументами, которые могут содержать пробелы:

CMD sh /path/to/script.sh arg1 "arg 2"
Если запустить эту команду в контейнере, то Docker попытается интерпретировать аргументы "arg" и "2" 
как две отдельные команды, что может привести к ошибке "command not found". 
Это происходит потому, что Docker разбирает команду на отдельные аргументы, 
разделенные пробелами, и не понимает, что двойные кавычки должны быть интерпретированы как единое целое.

Чтобы избежать этой проблемы, можно определить команду с использованием квадратных скобок, 
которые задают аргументы в формате массива JSON:

CMD ["sh", "/path/to/script.sh", "arg1", "arg 2"]
Такая команда задает каждый аргумент в виде отдельного элемента массива и позволяет корректно передать аргументы, 
содержащие пробелы, внутрь контейнера. Используя квадратные скобки, можно точно контролировать, какие аргументы 
будут переданы при запуске команды и избежать ошибок, связанных с неправильной интерпретацией аргументов.


####

Контейнеры и виртуальные машины (VM) являются двумя различными подходами к изоляции приложений. Ниже перечислены основные плюсы и минусы контейнеров в сравнении с виртуальными машинами:

Плюсы контейнеров:

Более легковесный и быстрый подход к изоляции приложений, чем виртуальные машины. Контейнеры используют общую операционную систему хоста, 
что позволяет им работать с меньшим объемом ресурсов (CPU, память, диск) и быстрее запускаться и останавливаться.
Более гибкий и удобный процесс развертывания приложений. Контейнеры могут быть созданы и развернуты на любом хосте, который поддерживает
контейнеризацию, без необходимости установки ОС и других зависимостей.
Лучшая портируемость между окружениями. Контейнеры гарантируют, что приложение будет работать на любой платформе, где есть совместимый контейнеризатор.
Более быстрое масштабирование приложений. Запуск и остановка контейнеров занимают меньше времени, чем запуск и остановка виртуальных машин, 
что делает масштабирование более эффективным.

Минусы контейнеров:

Меньшая изоляция приложений, чем у виртуальных машин. Контейнеры используют общую ОС хоста, поэтому существует определенный 
уровень взаимодействия и возможных угроз безопасности между контейнерами и хостом.
Ограниченные возможности работы с ОС и приложениями, которые не поддерживают контейнеризацию. Контейнеры не могут быть использованы 
для запуска приложений, которые требуют доступа к физическому железу или драйверам устройств.
Более сложный процесс настройки контейнеров, чем виртуальных машин. Настройка и управление контейнерами может быть сложнее, 
чем управление виртуальными машинами, особенно для больших приложений.

