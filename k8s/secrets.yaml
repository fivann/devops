# 1. Inspecting Secrets

# Kubernetes Secrets let you store and manage sensitive information, such as passwords, OAuth tokens, and ssh keys. Storing confidential information in a Secret is safer and more flexible than putting it verbatim in a Pod definition or in a container image. See Secrets design document for more information.

# A Secret is an object that contains a small amount of sensitive data such as a password, a token, or a key. Such information might otherwise be put in a Pod specification or in an image. Users can create Secrets and the system also creates some Secrets.

# Caution:
# Kubernetes Secrets are, by default, stored as unencrypted base64-encoded strings. They can be retrieved - as plain text - by anyone with API access, or anyone with access to Kubernetesâ€™ underlying data store, etcd.

# In order to safely use Secrets, it is recommended you (at a minimum):
# Enable Encryption at Rest for Secrets.
# https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/
# Enable or configure RBAC rules that restrict reading and writing the Secret. Be aware that secrets can be obtained implicitly by anyone with the permission to create a Pod.
# https://kubernetes.io/docs/reference/access-authn-authz/authorization/

# Task:
# Examine the Secrets in cluster and answer the questions below.
# $ kubectl get secrets
# $ kubectl get secrets --all-namespaces 

# Enter the type of recipe4 secret(s) in safe namespace
# $ kubectl describe secret -n safe recipe4

# Examine and decode the content of ingridients field in data section of recipe5 secret
# $ kubectl get secret -n safe recipe5 -o jsonpath='{.data.ingridients}' | base64 --decode

# Documentation:
# https://kubernetes.io/docs/concepts/configuration/secret/

##############################################################################################################

# 2. Creating Secrets From Files

# Howto:
# Using CLI:
# General command:
# $ kubectl create secret --help

# Create a secret using specified subcommand.

# Available Commands:
#   docker-registry Create a secret for use with a Docker registry
#   generic         Create a secret from a local file, directory or literal value
#   tls             Create a TLS secret

# Usage:
#   kubectl create secret [flags] [options]
  
# From file:
# $ kubectl create secret generic --help

# Create a secret based on a file, directory, or specified literal value.

#  A single secret may package one or more key/value pairs.

#  When creating a secret based on a file, the key will default to the basename of the file, and the
# value will default to the file content. If the basename is an invalid key or you wish to chose your
# own, you may specify an alternate key.

#  When creating a secret based on a directory, each file whose basename is a valid key in the
# directory will be packaged into the secret. Any directory entries except regular files are ignored
# (e.g. subdirectories, symlinks, devices, pipes, etc).

# Examples:
#   # Create a new secret named my-secret with keys for each file in folder bar
#   kubectl create secret generic my-secret --from-file=path/to/bar
  
#   # Create a new secret named my-secret with specified keys instead of names on disk
#   kubectl create secret generic my-secret --from-file=ssh-privatekey=path/to/id_rsa --from-file=ssh-publickey=path/to/id_rsa.pub
  
  ...
Using Definition File:
apiVersion: v1
kind: Secret
metadata:
  name: secret-name
type: Opaque
data:
  key1: base64_encoded_secret
  key2: base64_encoded_secret
  ...
  
# Task:
# Could you please create a Secret from files:

# secret name: admin-secret
# namespace: default
# from files: /data/username_file, /data/password_file

# SOLUTION
# $ kubectl create secret generic admin-secret --from-file=username_file=/data/username_file --from-file=password_file=/data/password_file -n default

# Verify:
# $ kubectl get secret admin-secret 
# NAME           TYPE     DATA   AGE
# admin-secret   Opaque   2      114s

# $ kubectl get secret admin-secret -o yaml
# apiVersion: v1
# data:
#   password_file: dmVyeXN0cm9uZ3Bhc3N3b3JkLjEwLjI0NC4wLjEK
#   username_file: c3VwZXJoYWNrZXIuMTAuMjQ0LjAuMQo=
# kind: Secret
# ...

# How to decrypt this weird string?
# $ echo 'dmVyeXN0cm9uZ3Bhc3N3b3JkLjEwLjI0NC4wLjEK' | base64 -d

Documentation:
https://kubernetes.io/docs/concepts/configuration/secret/


##################################################################################################

# 3. Creating Secrets Manually

# Howto:
# Using CLI:
# General command:

# $ kubectl create secret --help

# Create a secret using specified subcommand
# Available Commands:
#   docker-registry Create a secret for use with a Docker registry
#   generic         Create a secret from a local file, directory or literal value
#   tls             Create a TLS secret

# Usage:
#   kubectl create secret [flags] [options]
# From literals:
# $ kubectl create secret generic --help
# Create a secret based on a file, directory, or specified literal value.

#  A single secret may package one or more key/value pairs.

#  ...

# Examples:
#   ...  

#   # Create a new secret named my-secret with key1=supersecret and key2=topsecret
#   $ kubectl create secret generic my-secret --from-literal=key1=supersecret --from-literal=key2=topsecret
  
  ...
Using Definition File:
apiVersion: v1
kind: Secret
metadata:
  name: secret-name
type: Opaque
data:
  key1: base64_encoded_secret
  key2: base64_encoded_secret
  ...
  
# Task:
# Create a simple secret with the following requirements:
# Secret name: devops-secret
# Namespace: default
# Field username: ifedorov2
# Field password: ifedorov2_password
# Field email: ifedorov2@lab.playpit.net
# All string data schould be encoded (using base64)

# first we ENCODE:
# echo -n "ifedorov2" | base64
# etc. Then we INSERT:

apiVersion: v1
kind: Secret
metadata:
  name: devops-secret
  namespace: default
data:
  username: aWZlZG9yb3Yy
  password: aWZlZG9yb3YyX3Bhc3N3b3Jk
  email: aWZlZG9yb3YyQGxhYi5wbGF5cGl0Lm5ldA==
type: Opaque

# Documentation:
# https://kubernetes.io/docs/concepts/configuration/secret/

