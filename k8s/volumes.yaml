# 1. Pod Shared Volume: emptyDir: {}

# https://youtu.be/AXi2oENUJHo

# On-disk files in a Container are ephemeral, which presents some problems for non-trivial applications when running in Containers. 1. When a Container crashes, kubelet will restart it, but the files will be lost - the Container starts with a clean state. 2. When running Containers together in a Pod it is often necessary to share files between those Containers. The Kubernetes Volume abstraction solves both of these problems.

# An emptyDir volume is first created when a Pod is assigned to a Node, and exists as long as that Pod is running on that node. As the name says, it is initially empty. Containers in the Pod can all read and write the same files in the emptyDir volume, though that volume can be mounted at the same or different paths in each Container. When a Pod is removed from a node for any reason, the data in the emptyDir is deleted forever.

# Example Pod:
apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  initContainers:
  - image: image1
    name: init-contanier-1
    volumeMounts:
    - mountPath: /dir1
      name: pod-shared-volume

  containers:
  - image: image2
    name: container-a
    volumeMounts:
    - mountPath: /dir2
      name: pod-shared-volume

  - image: image3
    name: container-b
    volumeMounts:
    - mountPath: /dir3
      name: pod-shared-volume

  volumes:
  - name: pod-shared-volume
    emptyDir: {}
    
# In this example, all containers (init-contanier-1, container-a, container-b) have access to the same data located inside their pod.

# Task
# We are going to run a pod with Tomcat application, will deploy root’s “server page” before main process starts.
# Please, create a Pod with Init and Regular Containers. Share filesystem between containers. Expose pod to NodePort.

# Requirements
# Pod:
# Name: tomcat-with-init-emptydir

# Init Container:
# Image: busybox:1.34
# command: wget -O /webapps/ROOT/index.jsp https://playpit-labs-assets.s3-eu-west-1.amazonaws.com/tomcat/index.jsp
# Volume Mount Path: /webapps/ROOT/

# Container:
# Image: tomcat:9.0-jre8-alpine
# Volume Mount Path: /usr/local/tomcat/webapps/ROOT
# Volume:
# Name: shared-pod-volume
# type: emptyDir

# Service:
# Name: tomcat-with-init-emptydir-svc
# Type: NodePort
# Target Port: 8080
# Node Port: 30080

apiVersion: v1
kind: Pod
metadata:
  name: tomcat-with-init-emptydir
  ## LABELS IS EVERITHING!
  labels:
    app: tomcat-with-init-emptydir
spec:
  initContainers:
  - name: init-container
    image: busybox:1.34
    command: ["wget", "-O", "/webapps/ROOT/index.jsp", "https://playpit-labs-assets.s3-eu-west-1.amazonaws.com/tomcat/index.jsp"]
    volumeMounts:
    - name: shared-pod-volume
      mountPath: /webapps/ROOT/
  containers:
  - name: tomcat-container
    image: tomcat:9.0-jre8-alpine
    volumeMounts:
    - name: shared-pod-volume
      mountPath: /usr/local/tomcat/webapps/ROOT
  volumes:
  - name: shared-pod-volume
    emptyDir: {}
---
# In this example, the pod tomcat-with-init-emptydir contains two containers, an "init container" and a "regular container". The init container init-container is used to download a file from the internet, it uses the wget command to download index.jsp and save it in /webapps/ROOT/ directory. Then the init container mounts a volume shared-pod-volume in the path /webapps/ROOT/.

# The regular container tomcat-container is running the Tomcat application and it also mounts the volume shared-pod-volume in the path /usr/local/tomcat/webapps/ROOT, which means that the regular container can access the same files that init container has created in the shared volume.

# This pod also uses an emptyDir type of volume named shared-pod-volume, this type of volume is created when a Pod is assigned to a node, and exists as long as that Pod is running on that node. An emptyDir volume is initially empty when a Pod is created.

# To expose this pod to a NodePort you need to create a Service:
---
apiVersion: v1
kind: Service
metadata:
  name: tomcat-with-init-emptydir-svc
spec:
  selector:
    app: tomcat-with-init-emptydir
  ports:
  - name: http
    port: 8080
    targetPort: 8080
    nodePort: 30080
  type: NodePort


# Documentation
# https://kubernetes.io/docs/concepts/storage/volumes/#emptydir


# Persistent Volumes

# The PersistentVolume subsystem provides an API for users and administrators that abstracts details of how storage is provided from how it is consumed. To do this, we introduce two new API resources: PersistentVolume and PersistentVolumeClaim.

# A PersistentVolume (PV):
# is a piece of storage in the cluster that has been provisioned by an administrator or dynamically provisioned using Storage Classes. It is a resource in the cluster just like a node is a cluster resource. PVs are volume plugins like Volumes, but have a lifecycle independent of any individual Pod that uses the PV. This API object captures the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.

# A PersistentVolumeClaim (PVC):
# It’s a request for storage by a user. It is similar to a Pod. Pods consume node resources and PVCs consume PV resources. Pods can request specific levels of resources (CPU and Memory). Claims can request specific size and access modes (e.g., they can be mounted once read/write or many times read-only).

# While PersistentVolumeClaims allow a user to consume abstract storage resources, it is common that users need PersistentVolumes with varying properties, such as performance, for different problems. Cluster administrators need to be able to offer a variety of PersistentVolumes that differ in more ways than just size and access modes, without exposing users to the details of how those volumes are implemented. For these needs, there is the StorageClass resource.

# PV & PVC Explained:

# https://youtu.be/hAhoeg3RryY
# https://youtu.be/x2sMWUkasoE

# $ kubectl get pv
# $ kubectl get pv <<pv name>> -o yaml
# $ kubectl describe pv <<pv name>>

# Documentation:
# https://kubernetes.io/docs/concepts/storage/persistent-volumes/
# https://kubernetes.io/docs/concepts/storage/persistent-volumes/#reclaiming
# https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes
# https://www.learnitguide.net/2020/03/kubernetes-persistent-volumes-and-claims.html

# When a consumer is done with their volume, they can delete the PVC objects from the API that allows reclamation of the resource. The reclaim policy for a PersistentVolume tells the cluster what to do with the volume after it has been released of its claim. Currently, volumes can either be Retained, Recycled, or Deleted

# The Retain reclaim policy allows for manual reclamation of the resource
# The Delete reclaim policy removes both the PersistentVolume object from Kubernetes, as well as the associated storage asset in the external infrastructure (such as an AWS EBS or so on)
# The Recycle reclaim policy performs a basic scrub (rm -rf /thevolume/*) on the volume and makes it available again for a new claim -  Only if supported by the underlying volume plugin

# There are two ways PVs may be provisioned: statically or dynamically:

# Static way means that you have to specify PV and PVC should be configured to utilize existing PVs - all what we did on previous scenarios
# Dynamic implies the storage resources are dynamically provisioned using the provisioner specified by the StorageClass object (see user-guide). StorageClasses are essentially blueprints that abstract away the underlying storage provider, as well as other parameters, like disk-type (e.g.; solid-state vs standard disks).
# First, let’s check what StorageClasses our Cluster has

# kubectl get storageclass << sc_name >>
# kubectl describe storageclass << sc_name >>


# Creating PVC with StorageClass

# Here’s an example of PVC definition:

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mypvc
  namespace: testns
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 100Gi
  
  # Storage Class to be used
  storageClassName: gold
  
# Task:
# Please create PVC using Storage Class Name playpit-labs-storage

# Requirements:
# PVC Name: pvc-with-sc
# PVC Requested Size: 2Gi
# PVC Namespace: default
# Labels:
# pvc=2gbi

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-with-sc
  labels:
    pvc: 2gbi
  namespace: default
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi
  storageClassName: playpit-labs-storage

# This configuration creates a PVC named pvc-with-sc with a requested storage size of 2Gi and storage class playpit-labs-storage in the namespace default, it also sets the label "pvc: 2gbi" in the metadata section.

# When a pod requests the PVC, Kubernetes dynamically provisions the volume based on the storage class requested, the storage class has to be pre-configured in the cluster.
# Please make sure that the storage class 'playpit-labs-storage' exist in the cluster, also the namespace 'default' should exist before you apply the yaml file.


# Using PVC as Volume

# Let’s check our pvc right after its creation:

# $ kubectl get pvc pvc-with-sc
# NAME          STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS           AGE
# pvc-with-sc   Pending                                      playpit-labs-storage   2m21s
# It’s in status Pending which means that PV will be created once the first its consumer appears. Need to create a Pod using this pvc.

# Let’s do this

# Task:
# Create a Pod which uses pvc-with-sc pvc

# Requirements:
# Pod name: testing-pvc-sc
# Container image: busybox:1.34
# Container command: sleep infinity
# Volume:
# persistentVolumeClaim: pvc-with-sc
# volume Mount: /data
# Verify:
# $ kubectl get pv
# NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                             STORAGECLASS           REASON   AGE
# ...
# pvc-2d4be53d-d151-459d-8a0b-9f1315a19142   2Gi        RWO            Delete           Bound    default/pvc-with-sc               playpit-labs-storage            2m4s
# ...

# $ kubectl get pvc pvc-with-sc
# NAME                      STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS           AGE
# pvc-with-sc               Bound    pvc-2d4be53d-d151-459d-8a0b-9f1315a19142   2Gi        RWO            playpit-labs-storage   2m59s

# $ kubectl get po testing-pvc-sc
# NAME             READY   STATUS    RESTARTS   AGE
# testing-pvc-sc   1/1     Running   0          38s

# In this configuration, you are creating a Pod named testing-pvc-sc that runs a single container based on the image busybox:1.34 and this container runs the command sleep infinity.
# The Pod also mounts a volume named pvc-with-sc to the path /data inside the container, this volume is using the previously created PVC pvc-with-sc.
# It's important to make sure that the pvc pvc-with-sc exist and accessible in the cluster before you apply the yaml file.


# Setting “default” StorageClass

# Kubernetes v1.6 added the ability to set a default storage class. This is the storage class that will be used to provision a PV if a user does not specify any one in a PVC.
# You can define a default storage class by setting the annotation storageclass.kubernetes.io/is-default-class to true in the storage class definition. According to the specification, any other value or absence of the annotation is interpreted as false.

# It is possible to configure an existing storage class to be the default storage class by using the following command:

kubectl patch storageclass <storage-class-name> -p '{
  "metadata": {
    "annotations": {
      "storageclass.kubernetes.io/is-default-class":"true"
    }
  }
}'
# Similarly, you can remove the default storage class annotation by using the following command:

kubectl patch storageclass <storage-class-name> -p '{
  "metadata": {
    "annotations": {
      "storageclass.kubernetes.io/is-default-class":"false"
    }
  }
}'

# Task:
# Set playpit-labs-storage a default StorageClass for our Cluster

kubectl patch storageclass playpit-labs-storage -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

# Verification:
# Before patching:
# $ kubectl get sc
# NAME                    PROVISIONER             ...
# playpit-labs-storage    rancher.io/local-path   ...

# After patching:
# $ kubectl get sc
# NAME                             PROVISIONER             ...
# playpit-labs-storage (default)   rancher.io/local-path   ...

# Documentation:
# https://kubernetes.io/docs/tasks/administer-cluster/change-default-storage-class/

# Using default StorageClass

# Usually all “turn-key” Kubernetes Clusters have “built-in” storage classes and their “native” provisioners.
# The following table provides more detail on default storage classes pre-installed by cloud provider as well as the specific parameters used by these defaults.

# Cloud Provider	      Default StorageClass Name	  Default Provisioner
# Amazon Web Services   gp2                       	aws-ebs
# Microsoft Azure	      standard	                  azure-disk
# Google Cloud Platform	standard	                  gce-pd
# OpenStack	            standard	                  cinder
# VMware vSphere	      thin	                      vsphere-volume

# How do I use a default StorageClass?
# If your cluster has a default StorageClass that meets your needs, then all you need to do is create a PersistentVolumeClaim (PVC) and the default provisioner will take care of the rest – there is no need to specify the storageClassName:

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mypvc
  namespace: testns
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 100Gi
      
# Task:
# Please create PVC using default StorageAccount (without mentioning playpit-labs-storage)

# Requirements:
# PVC Name: pvc-with-default-sc
# PVC Requested Size: 2Gi
# PVC Namespace: default

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-with-default-sc
  namespace: default
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 2Gi

# In this configuration, the PVC named pvc-with-default-sc is created in the namespace default, it requests for a storage size of 2Gi and it does not mention any storage class.
# When a pod requests the PVC and does not mention any storage class name, Kubernetes will automatically use the default storage class that was configured in the cluster.
# Please make sure that the namespace 'default' exists before you apply the yaml file.

# Creating Custom StorageClass
# To add your own storage class, first determine which provisioners work in your cluster. Then, create a StorageClass object with parameters customized to meet your needs. For many users, the easiest way to create the object is to write a yaml file and apply it with kubectl create -f. The following is an example of a StorageClass for Google Cloud Platform named gold that creates a pd-ssd. Since multiple classes can exist within a cluster, the administrator may leave the default enabled for most workloads (since it uses a pd-standard), with the gold class reserved for workloads that need extra performance.

kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: gold
provisioner: kubernetes.io/gce-pd
parameters:
  type: pd-ssd
  
# Task:
# Create own StorageClass named ifedorov2-storage-class. Find which provisioner is used by playpit-labs-storage and use it.
#  Obviously it should be similar to playpit-labs-storage as much as possible :) Don’t set any other parameters rather then required.

apiVersion: v1
kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: ifedorov2-storage-class
provisioner: <provisioner>

In this configuration, you are creating a new Storage Class named ifedorov2-storage-class and set the provisioner to be the same as the playpit-labs-storage class.

# To find the provisioner name you can use the kubectl command:
#   $ kubectl describe storageclass playpit-labs-storage 
# this will give you a detailed view of the storage class including the provisioner name.

# You can also use this command to view all storage classes available

#   $ kubectl get storageclass 
# Please make sure that the provisioner is accessible and configured in your cluster, also the user running the command should have enough permissions to create a new storage class.

# Can I delete/turn off the default StorageClasses?
# You cannot delete the default storage class objects provided. Since they are installed as cluster addons, they will be recreated if they are deleted.
# You can, however, disable the defaulting behavior by removing (or setting to false) the following annotation: storageclass.beta.kubernetes.io/is-default-class.

# If there are no StorageClass objects marked with the default annotation, then PersistentVolumeClaim objects (without a StorageClass specified) will not trigger dynamic provisioning. They will, instead, fall back to the legacy behavior of binding to an available PersistentVolume object.

# Can I assign my existing PVs to a particular StorageClass?
# Yes, you can assign a StorageClass to an existing PV by editing the appropriate PV object and adding (or setting) the desired storageClassName field to it.
# What happens if I delete a PersistentVolumeClaim (PVC)?
# If the volume was dynamically provisioned, then the default reclaim policy is set to “delete”. This means that, by default, when the PVC is deleted, the underlying PV and storage asset will also be deleted. If you want to retain the data stored on the volume, then you must change the reclaim policy from “delete” to “retain” after the PV is provisioned.
# Reference:
# https://kubernetes.io/blog/2017/03/dynamic-provisioning-and-storage-classes-kubernetes/
