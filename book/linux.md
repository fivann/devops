Runlevel 0: Выключение системы.
Runlevel 1: Однопользовательский режим (техобслуживание).
Runlevel 2: Многопользовательский режим без сети.
Runlevel 3: Многопользовательский режим с сетью, без графики.
Runlevel 4: Не используется (можно настроить для своих задач).
Runlevel 5: Многопользовательский режим с графикой.
Runlevel 6: Перезагрузка системы.


r: чтение (read)
w: запись (write)
x: выполнение (execute)

suid (setuid): выполняется с правами владельца файла.
sgid (setgid): выполняется с правами группы файла.
sticky bit: файл в каталоге можно удалять только владельцу.

Права для пользователя, группы, остальных:
-rwxr-xr--:
1. Владелец: чтение, запись, выполнение.
2. Группа: чтение, выполнение.
3. Остальные: чтение.

Изменение прав:
chmod +x файл — добавляет права выполнения.
chmod 4755 файл — устанавливает suid.
chmod 1777 каталог — устанавливает sticky bit.


Каждая цифра в правах представляет три бита (rwx) и переводится в восьмеричную систему:

1. r (read) = 4
2. w (write) = 2
3. x (execute) = 1

Права считаются по сумме значений для каждой категории (владелец, группа, остальные):

Пример 4755:
- 4: suid (Set UID) — добавляет 4 к первой цифре (7 становится 4+7).
- 7: владелец — чтение (4) + запись (2) + выполнение (1) = 7.
- 5: группа — чтение (4) + выполнение (1) = 5.
- 5: остальные — чтение (4) + выполнение (1) = 5.

Таким образом, 4755 = suid + rwx для владельца, r-x для группы и остальных.

#### Сигналы и вызовы

SIGHUP (1): Перезагрузка процесса (обычно пересчитывает конфиги).
SIGINT (2): Прерывание процесса (Ctrl+C в терминале).
SIGQUIT (3): Завершение с дампом памяти.
SIGKILL (9): Немедленное завершение процесса (нельзя перехватить).
SIGTERM (15): Корректное завершение процесса.
SIGSTOP (19): Остановка процесса (нельзя перехватить).
SIGCONT (18): Продолжение остановленного процесса.
SIGSEGV (11): Ошибка сегментации (недопустимая память).
SIGALRM (14): Таймер истек.
SIGUSR1/2 (10, 12): Пользовательские сигналы для кастомных задач.

**Прерываемые системные вызовы**: могут быть прерваны сигналами. Если вызов прерывается, возвращается ошибка (обычно `EINTR`).
- `read()`
- `write()`
- `wait()`
- `select()`
- `poll()`
- `sleep()`
- `accept()`
- `connect()`

**Непрерываемые системные вызовы**: не могут быть прерваны сигналами, обычно это вызовы, работающие с критическими операциями (например, с I/O).
- Ожидание в состоянии `D` (uninterruptible sleep), например:
  - Операции на блочных устройствах (диски).
  - Низкоуровневый ввод-вывод, например `ioctl()`.
  - Некоторые сетевые операции.

Непрерываемые вызовы обычно связаны с ожиданием аппаратных ресурсов.


Запуск процесса:
1. **fork()**: Родительский процесс (например, оболочка) вызывает fork(), создавая копию себя (дочерний процесс). Оба процесса продолжают работу параллельно.
2. **exec()**: Дочерний процесс вызывает exec(), заменяя свой код и контекст новым исполняемым файлом. Этот файл загружается в память, и процесс начинает его выполнение. Например, запускается программа (ls, cat и т.д.).
3. **pid**: Каждый процесс получает уникальный идентификатор процесса (PID). Родительский процесс может контролировать дочерний через этот PID.

Процессы имеют следующие атрибуты:
- **PID**: уникальный идентификатор процесса.
- **PPID**: идентификатор родительского процесса.
- **UID**: пользователь, под которым запущен процесс.
- **GID**: группа, к которой относится процесс.
- **Контекст выполнения**: состояние регистров процессора, контексты памяти (виртуальная память), файловые дескрипторы.

Ресурсы процесса:
1. **CPU**: используется для выполнения инструкций процесса.
2. **Оперативная память (RAM)**: выделяется для хранения данных и кода процесса. Процессы используют виртуальную память, управляемую ядром.
3. **Файловые дескрипторы**: каждый процесс имеет открытые файлы/сокеты, которые доступны через дескрипторы (stdin, stdout, stderr).
4. **Системные вызовы**: процесс использует системные вызовы для взаимодействия с ядром (например, для работы с файлами, сетями).
5. **Процессорное время**: ядро распределяет ресурсы процессора между процессами, планируя их выполнение по очереди.

Завершение процесса:
1. **exit()**: Процесс завершает свою работу с системным вызовом exit(), передавая статус завершения (exit code).
2. **SIGTERM**: Процесс может быть завершен внешне с помощью сигнала SIGTERM (корректное завершение) или SIGKILL (насильственное завершение).
3. **wait()**: Родительский процесс вызывает wait(), чтобы получить статус завершения дочернего процесса и очистить его записи из таблицы процессов. Если родитель не вызовет wait(), дочерний процесс становится "зомби".

Завершившийся процесс освобождает все использованные ресурсы (CPU, память, дескрипторы файлов).

-----

Если у файла есть права только на запись и выполнение, его можно считать с помощью команды `sed`, поскольку она может обрабатывать файлы, не требуя явных прав на чтение.

Пример команды:
sed '' ./файл

Это сработает, потому что `sed` открывает файл как исполняемый, чтобы обработать его содержимое, при этом нет необходимости в правах на чтение. Такой способ позволяет обойти отсутствие прав на чтение файла.

-----

Load Average: это среднее количество процессов, ожидающих выполнения или использования ресурсов (CPU или I/O) за последние 1, 5 и 15 минут.

Как считается:
1. Ядро регулярно (раз в несколько секунд) проверяет количество процессов в очереди на выполнение.
2. Load average показывает не количество занятых ядер, а количество процессов, которые активны или ожидают ресурсов (включая CPU и I/O).
3. Формула расчета основывается на экспоненциальном скользящем среднем, чтобы сгладить кратковременные пики нагрузки.

Значение:
- 1.0 = 100% загруженность одного CPU.
- Значение >1.0 на многоядерной системе может означать, что система справляется с нагрузкой.

Высокий load average при низкой загрузке процессора может быть вызван:

1. **I/O-задержки**: Процессы ждут завершения операций ввода-вывода (дисковый доступ, сеть).
2. **Ожидание блокировок**: Процессы заблокированы, ожидая доступа к разделяемым ресурсам.
3. **Ожидание swap**: Процессы ждут выгрузки или загрузки данных из swap, что замедляет их выполнение.
4. **Количество процессов**: Много процессов запущено, но они спят или ждут ресурсов.

Загрузка CPU может быть низкой, если процессы ожидают чего-то, кроме вычислительных мощностей.

----

Процессы в Linux могут находиться в следующих состояниях:

1. **R (Running)**: Процесс выполняется или готов к выполнению.
2. **S (Sleeping)**: Процесс ожидает события (например, ввода-вывода). 
   - **Interruptible**: Ожидание может быть прервано (обычное ожидание).
3. **D (Uninterruptible sleep)**: Процесс ждёт ресурса (обычно I/O) и не может быть прерван.
4. **Z (Zombie)**: Процесс завершён, но ещё не удалён родительским процессом.
5. **T (Stopped)**: Процесс остановлен (например, сигналом SIGSTOP или через отладчик).
6. **X (Dead)**: Процесс завершился, но не существует (редко отображается).

Это основные состояния процессов в Linux.

----

Убрать зомби-процессы:

1. Зомби-процессы не могут быть убиты напрямую, так как они уже завершены.
2. Родительский процесс должен вызвать `wait()`, чтобы очистить информацию о зомби. Если родитель не делает этого, завершите родительский процесс с помощью команды:
   kill -9 <PID родителя>
   Это приведёт к тому, что зомби-процессы будут "усыновлены" процессом init (PID 1), который затем удалит их.

Опасность большого количества зомби-процессов:
- Занимают записи в таблице процессов, что может исчерпать лимит и привести к невозможности запуска новых процессов.


----

1. **Как работает init система?**
   Инициализирует систему, запускает процессы и сервисы (systemd, SysV init).

2. **Разница между процессами и потоками?**
   Процесс: отдельное приложение с собственным адресным пространством. Поток: легковесный процесс, использующий память процесса.

3. **Как работает системный вызов `fork()`?**
   Создаёт новый процесс (дочерний), копируя текущий процесс (родитель).

4. **Как работает `exec()`?**
   Заменяет текущий процесс новым исполняемым файлом, не меняя PID.

5. **Что такое swap и зачем он нужен?**
   Используется, когда заканчивается RAM. Данные переносятся в swap на диск для освобождения оперативной памяти.

6. **Разница между soft и hard ссылками?**
   Soft link (символическая): указывает на файл. Hard link: другая точка входа в файл, разделяет inode.

7. **Что такое `nice` и `renice`?**
   Используются для задания приоритета процессам. Чем ниже nice-значение, тем выше приоритет.

8. **Как работают права доступа в Linux?**
   Права на чтение (r), запись (w) и выполнение (x) для владельца, группы и остальных.

9. **Что такое sticky bit?**
   В директории с sticky bit файлы могут удалять только их владельцы, даже если есть другие права.

10. **Что такое setuid и setgid?**
    setuid: выполняет файл с правами владельца. setgid: выполняет с правами группы.

11. **Как просмотреть запущенные процессы?**
    Используются команды `ps`, `top`, `htop`, `pidof`.

12. **Как работает управление памятью в Linux?**
    Использует виртуальную память, выделяет страницы процессам, управляет swap и кешем страниц.

13. **Что такое cgroups?**
    Контроль и ограничение ресурсов (CPU, память, I/O) для групп процессов.

14. **Как работают runlevels или targets в systemd?**
    Уровни запуска (runlevels) задают состояние системы. Targets в systemd — аналог, например `multi-user.target`.

15. **Что такое inodes?**
    Структура, содержащая информацию о файле (размер, права, временные метки), но не имя файла.

16. **Как работает `cron` и `at`?**
    `cron` для регулярного запуска задач по расписанию, `at` — для однократного запуска задач в будущем.

17. **Что такое `/proc` и для чего используется?**
    Виртуальная файловая система, представляющая информацию о процессах и системе в реальном времени.

18. **Как работает `lsof`?**
    Показывает открытые файлы процессами, полезно для поиска блокировок и сетевых подключений.

19. **Разница между `df` и `du`?**
    `df` показывает свободное место на дисках, `du` — использование дискового пространства в каталогах и файлах.

20. **Как управлять загрузочными модулями ядра?**
    Используются команды `lsmod`, `modprobe`, `rmmod` для загрузки, просмотра и удаления модулей ядра.

----

1. **Можно ли удалить каталог с файлами, если у него нет прав на запись?**
   Да, можно, если у родительской директории есть права на запись.

2. **Что произойдет, если удалить файл, который в данный момент открыт процессом?**
   Файл удалится из файловой системы, но процесс сможет продолжить работу с ним до завершения; место освободится после закрытия дескриптора.

3. **Как открыть файл на запись, но не перезаписывать его?**
   Открыть с флагом `O_APPEND`, чтобы данные добавлялись в конец файла.

4. **Можно ли запустить скрипт без прав на выполнение?**
   Да, можно, если запустить через интерпретатор, например: `bash script.sh`.

5. **Что произойдет, если отправить сигнал `SIGKILL` процессу с PID 1?**
   Процесс с PID 1 (обычно systemd) не может быть убит сигналом `SIGKILL`.

6. **Можно ли переименовать открытую директорию?**
   Да, директорию можно переименовать, даже если она открыта, это не повлияет на процессы.

7. **Почему `kill -9` не всегда завершает процесс?**
   Если процесс находится в состоянии `D` (uninterruptible sleep), его нельзя убить сигналами.

8. **Что такое `null` в Linux и можно ли туда записывать данные?**
   `/dev/null` — это специальное устройство, которое "глотает" данные, можно записывать, но они будут отброшены.

9. **Можно ли создать файл с символом `/` в названии?**
   Нет, `/` зарезервирован как разделитель директорий в файловой системе.

10. **Что произойдет, если завершить родительский процесс без завершения дочернего?**
   Дочерний процесс станет "сиротой" и будет передан процессу с PID 1 (init/systemd).

11. **Почему команда `cd` является встроенной в оболочку, а не отдельной программой?**
   `cd` изменяет текущую директорию процесса, а отдельная программа не смогла бы изменить среду оболочки.

12. **Что делает команда `rm -rf /` и можно ли ее остановить?**
   Удаляет все файлы и директории с корня файловой системы. Можно остановить с помощью `Ctrl+C`, если не все удалено.

13. **Можно ли запустить команду без использования терминала?**
   Да, можно через cron, systemd, atd или фоновый процесс с `nohup`.

14. **Что случится, если удалённый NFS-диск станет недоступен, но процесс пытается к нему обратиться?**
   Процесс зависнет в состоянии `D`, ожидая завершения операции ввода-вывода.

15. **Как просмотреть содержимое файла, если нет прав на чтение, но есть права на выполнение?**
   Можно запустить файл с помощью интерпретатора или использовать `sed`, если это текстовый файл.

16. **Почему после команды `cd /tmp && rm -rf *` текущая директория остается `/tmp`?**
   `rm` удаляет содержимое, но не меняет текущую рабочую директорию процесса.

17. **Почему копирование больших файлов через `cp` может быть медленным, но `dd` быстрее?**
   `dd` позволяет управлять размером блоков для копирования, что может увеличить скорость за счёт оптимизации I/O операций.

18. **Как прочитать содержимое файла с правами только на запись и выполнение?**
   Использовать команду `sed`, которая может читать файл без явных прав на чтение.

19. **Почему размер каталога, показанный командой `du`, отличается от размера файлов в каталоге?**
   `du` учитывает размер всех файлов, включая скрытые, ссылки и метаданные, а не только видимые файлы.

20. **Можно ли удалить файл с правами на чтение и выполнение, но без прав на запись?**
   Да, если у вас есть права на запись в родительском каталоге, можно удалить файл, даже если у него нет прав на запись.


----

inode (индексный узел) — это структура данных в файловой системе Linux, содержащая метаинформацию о файле или директории, но не само содержимое файла или его имя.

**Что хранится в inode:**
1. Права доступа (rwx) и тип файла.
2. Владелец (UID) и группа (GID).
3. Размер файла.
4. Временные метки: создание, модификация, доступ (ctime, mtime, atime).
5. Счетчик ссылок (сколько имен или ссылок указывает на файл).
6. Адреса блоков данных на диске (указатели на содержимое файла).
7. Флаги атрибутов (например, скрыт или нет).

**Чего нет в inode:**
- Имени файла. Имена хранятся в директориях, которые ссылаются на соответствующие inode.

**Работа inode:**
- Когда вы создаете файл, для него выделяется inode.
- Системные вызовы (например, `stat`) получают информацию из inode.
- При доступе к файлу ОС использует inode для нахождения его данных на диске.

**Использование:**
- Каждый файл и директория имеют свой inode.
- При создании нового файла в файловой системе используется один inode.
- Если inode заканчиваются (например, на диске заполнен лимит), новые файлы создать нельзя, даже если есть свободное место.

**Hard links и inod

----

1. **Ввод команды**: В терминале пользователь вводит команду `ls -hal`. Оболочка (bash, zsh и т.д.) получает эту строку.

2. **Разбор аргументов**: Оболочка парсит команду и разделяет её на:
   - Исполняемый файл: `ls`.
   - Аргументы: `-hal`.

3. **Поиск исполняемого файла**: Оболочка ищет файл `ls` в каталогах, указанных в переменной среды `PATH`. Находит его, например, в `/bin/ls`.

4. **Вызов `fork()`**: Оболочка вызывает системный вызов `fork()`, создавая дочерний процесс. Дочерний процесс является копией оболочки и наследует все её ресурсы.

5. **Вызов `exec()`**: Дочерний процесс вызывает системный вызов `execve()` (или другой `exec*()`), заменяя свою память программой `/bin/ls`:
   - Системный вызов `execve()` загружает исполняемый файл `ls` в адресное пространство дочернего процесса.
   - Аргументы `-hal` передаются новой программе в качестве параметров.

6. **Системные вызовы ядра для работы с файлами**: 
   - Программа `ls` через системные вызовы взаимодействует с файловой системой:
     - `open()` для открытия каталога (в данном случае текущего `.`).
     - `readdir()` для чтения содержимого каталога.
     - `stat()` для получения информации о каждом файле (размер, права, время изменения).

7. **Обработка параметров**: 
   - Флаг `-h`: вывод размеров файлов в человекочитаемом формате.
   - Флаг `-a`: вывод всех файлов, включая скрытые.
   - Флаг `-l`: детальная информация о файлах (размер, права доступа, время изменения и т.д.).

8. **Вывод данных**:
   - `ls` использует системный вызов `write()`, чтобы передать вывод на стандартный поток вывода (stdout), который связан с терминалом.

9. **Завершение процесса**:
   - После завершения выполнения команда `ls` вызывает системный вызов `exit()`, чтобы завершить процесс.
   - Оболочка получает от дочернего процесса код завершения через системный вызов `wait()`.

10. **Освобождение ресурсов**: Ядро ОС освобождает память, файловые дескрипторы и другие ресурсы, использованные процессом `ls`.


----

#### Что крутится на сервере

Чтобы понять, какие процессы работают на сервере и что сервер делает, можно выполнить следующие шаги:

1. **Просмотр активных процессов**:
   - Используйте команду `ps aux` для вывода списка всех процессов, работающих на сервере.
   - Альтернатива: `top` или `htop` для интерактивного просмотра процессов с обновлением в реальном времени.
   
   Это покажет информацию о каждом процессе, включая владельца, PID, использование CPU и памяти.

2. **Просмотр процессов, использующих сеть**:
   - Команда `netstat -tuln` или `ss -tuln` покажет все открытые порты и IP-адреса, которые сервер "слушает" (состояние LISTEN).
   - Флаги:
     - `-t`: TCP.
     - `-u`: UDP.
     - `-l`: слушающие порты.
     - `-n`: не отображать имена хостов и сервисов, только номера портов.

3. **Связывание процессов с портами**:
   - Команда `lsof -i` покажет список процессов, которые используют сеть (открытые сетевые подключения и порты).
   - Например, `lsof -i :80` покажет процессы, использующие порт 80 (HTTP).

4. **Просмотр загруженности сети**:
   - Используйте команду `iftop` или `nload` для интерактивного мониторинга сетевой активности в реальном времени.

5. **Просмотр активных подключений**:
   - `netstat -an` или `ss -an` для отображения активных сетевых соединений и их состояний (ESTABLISHED, TIME_WAIT, etc.).

6. **Мониторинг логов системы**:
   - Используйте команду `tail -f /var/log/syslog` или `journalctl -f` (если используется systemd) для просмотра системных логов в реальном времени.
   - Логи помогут понять, какие действия выполняются на сервере и какие процессы генерируют активность.

7. **Анализ загрузки CPU/памяти**:
   - Команда `top` показывает, какие процессы занимают больше всего ресурсов (CPU, память).
   - Также можно использовать `vmstat` или `sar` для анализа системной загрузки в течение времени.

8. **Просмотр открытых файлов и дескрипторов**:
   - Команда `lsof` покажет все открытые файлы и устройства, используемые процессами.
   - Это помогает понять, какие файлы или устройства сервер использует активно.

9. **Просмотр демонов и сервисов**:
   - Команда `systemctl list-units --type=service` (если используется systemd) для отображения всех активных сервисов.
   - Для старых систем: `service --status-all`.

10. **Анализ использования диска и I/O**:
    - Команды `iostat`, `iotop` и `df -h` помогут понять, какие процессы активно используют диск и ввод/вывод.


----На собеседовании могут задать следующие вопросы из серии "в чем разница между":

1. **В чем разница между процессом и потоком?**
   Процесс — это независимая единица, имеющая свое адресное пространство. Поток — легковесный процесс, который использует общее адресное пространство процесса.

2. **В чем разница между hard link и soft link?**
   Hard link — это другая точка входа в файл с тем же inode. Soft link (символическая ссылка) указывает на другой файл по имени, и может сломаться, если файл удален.

3. **В чем разница между `fork()` и `exec()`?**
   `fork()` создает копию текущего процесса. `exec()` заменяет текущий процесс новым, загружая другую программу.

4. **В чем разница между `cron` и `at`?**
   `cron` запускает задания регулярно по расписанию, `at` — однократно в заданное время.

5. **В чем разница между `/dev/null` и `/dev/zero`?**
   `/dev/null` "глотает" любые данные и ничего не возвращает. `/dev/zero` возвращает нулевые байты при чтении.

6. **В чем разница между `df` и `du`?**
   `df` показывает доступное и используемое место на дисках. `du` показывает использование дискового пространства в каталогах и файлах.

7. **В чем разница между TCP и UDP?**
   TCP — это надежный протокол с установлением соединения, проверкой целостности и контролем потока. UDP — протокол без установления соединения, быстрее, но ненадежен.

8. **В чем разница между `kill` и `kill -9`?**
   `kill` отправляет сигнал процессу (по умолчанию `SIGTERM`, процесс может обработать и завершиться корректно). `kill -9` (SIGKILL) насильственно завершает процесс без возможности обработки.

9. **В чем разница между `ls` и `find`?**
   `ls` показывает содержимое директории. `find` ищет файлы по критериям (имя, размер, дата и т.д.).

10. **В чем разница между swap и RAM?**
    RAM — это физическая оперативная память. Swap — виртуальная память на диске, используется, когда не хватает RAM.

11. **В чем разница между `chmod` и `chown`?**
    `chmod` изменяет права доступа к файлам и директориям. `chown` изменяет владельца и группу файла.

12. **В чем разница между `apt-get` и `apt`?**
    `apt-get` — старый инструмент для управления пакетами, `apt` — новый, объединяющий функционал `apt-get` и `apt-cache`, с улучшенным интерфейсом.

13. **В чем разница между pipe (`|`) и redirect (`>`)?**
    Pipe передает вывод одной команды на ввод другой. Redirect перенаправляет вывод в файл.

14. **В чем разница между `/etc/passwd` и `/etc/shadow`?**
    `/etc/passwd` содержит информацию о пользователях, но хэшированные пароли там не хранятся. `/etc/shadow` содержит хэшированные пароли и используется для повышения безопасности.

15. **В чем разница между `symlink` и `bind mount`?**
    Symlink — символическая ссылка на файл или директорию. Bind mount — монтирование директории в другое место файловой системы, фактически создавая точную копию доступности.

16. **В чем разница между RAID 0 и RAID 1?**
    RAID 0 — объединение дисков для увеличения скорости и емкости, но без избыточности. RAID 1 — зеркалирование, данные дублируются для повышения отказоустойчивости.

17. **В чем разница между IPv4 и IPv6?**
    IPv4 использует 32-битные адреса, что ограничивает количество уникальных IP. IPv6 использует 128-битные адреса, предоставляя значительно большее адресное пространство.

18. **В чем разница между `yum` и `rpm`?**
    `yum` — менеджер пакетов, который управляет зависимостями и репозиториями, `rpm` — низкоуровневый инструмент для установки отдельных пакетов без управления зависимостями.

19. **В чем разница между `nohup` и `&`?**
    `nohup` позволяет продолжить выполнение команды после выхода из терминала. `&` запускает процесс в фоне, но при закрытии терминала процесс завершится.

20. **В чем разница между `mount` и `umount`?**
    `mount` подключает файловую систему или устройство. `umount` — отключает ранее смонтированную файловую систему или устройство.


---- Файловые системы


Файловая система в Linux — это структура, которая организует и управляет хранением данных на носителях (жестких дисках, SSD, флешках и т.д.).

Основные типы файловых систем и их особенности:

1. **ext2 (Second Extended Filesystem)**:
   - Одна из старейших файловых систем для Linux.
   - Не поддерживает журналирование (journaling).
   - Используется на небольших устройствах или в системах, где важна простота.

2. **ext3 (Third Extended Filesystem)**:
   - Улучшенная версия ext2 с поддержкой журналирования.
   - Журналирование улучшает восстановление после сбоев.
   - Совместима с ext2, что позволяет без форматирования перейти на ext3.

3. **ext4 (Fourth Extended Filesystem)**:
   - Расширение ext3 с дополнительными возможностями.
   - Поддержка больших файлов (до 16 ТБ) и файловых систем (до 1 ЭБ).
   - Более эффективное управление фрагментацией, быстрее работает с метаданными.
   - Асинхронное журналирование для повышения производительности.

4. **XFS**:
   - Высокопроизводительная журналируемая файловая система, ориентированная на большие объемы данных и высокую производительность.
   - Хорошо работает с большими файлами и параллельными операциями.
   - Используется в корпоративных средах, например, в Red Hat Enterprise Linux по умолчанию.

5. **Btrfs (B-tree File System)**:
   - Современная файловая система с поддержкой моментальных снимков (snapshots), самовосстановления данных, сжатия и многодисковых конфигураций (RAID).
   - Фокусируется на целостности данных и продвинутых функциях управления.
   - Применяется для больших массивов данных и контейнерных систем (например, в некоторых дистрибутивах SUSE).

6. **ReiserFS**:
   - Журналируемая файловая система с эффективным управлением небольшими файлами.
   - Отличается высокой скоростью работы с директориями и маленькими файлами, но в последнее время реже используется из-за перехода на ext4 и Btrfs.

7. **ZFS (Zettabyte File System)**:
   - Файловая система с поддержкой управления томами, дедупликации данных, сжатия и моментальных снимков.
   - Изначально разработана для Solaris, но доступна в Linux.
   - Очень надежная и масштабируемая, но требует больше ресурсов.

8. **F2FS (Flash-Friendly File System)**:
   - Оптимизирована для флеш-накопителей и SSD.
   - Спроектирована для уменьшения износа флеш-памяти и повышения производительности.

9. **VFAT**:
   - Вариант FAT32, используемый для совместимости с Windows.
   - Поддерживает большие файлы и диски, но не журналируется.
   - Подходит для обмена данными между системами Linux и Windows.

10. **NTFS**:
    - Основная файловая система Windows, но также поддерживается Linux.
    - Используется для работы с внешними жесткими дисками и совместимости с Windows.

### Основные отличия файловых систем:
- **Журналирование** (journaling): XFS, ext3, ext4, Btrfs используют журналирование для повышения устойчивости к сбоям.
- **Производительность**: XFS и Btrfs показывают высокую производительность на больших объёмах данных и при параллельной работе.
- **Поддержка больших файлов и томов**: ext4, XFS и Btrfs поддерживают огромные файлы и тома до терабайтов и эксабайтов.
- **Управление моментальными снимками (snapshots)**: Btrfs и ZFS поддерживают создание и управление моментальными снимками для резервирования и восстановления данных.
- **Совместимость**: VFAT и NTFS используются для работы с Windows-системами, но имеют ограниченные возможности по сравнению с журналируемыми файловыми системами Linux.

----

Конвейеры команд (Pipelines) в Linux позволяют передавать вывод одной команды на вход другой команды с помощью символа `|`. Это позволяет комбинировать несколько команд для обработки данных без использования временных файлов.

Основной синтаксис:
команда1 | команда2 | команда3

### Примеры:

1. **Передача вывода одной команды в другую**:
   ls -l | grep "txt"
   Вывод списка файлов передается команде grep для фильтрации файлов с расширением .txt.

2. **Подсчет количества строк в выводе**:
   cat файл.txt | wc -l
   Вывод команды cat (содержимое файла) передается команде wc для подсчета количества строк.

3. **Поиск активных процессов и их фильтрация**:
   ps aux | grep "apache" | awk '{print $2}'
   Сначала выводятся все процессы, затем фильтруются по названию apache, а затем команда awk выводит только PID процессов.

4. **Сортировка и вывод уникальных строк**:
   cat файл.txt | sort | uniq
   Вывод файла сортируется, затем дублирующиеся строки удаляются командой uniq.

5. **Вывод с постраничной навигацией**:
   dmesg | less
   Системные сообщения выводятся постранично с помощью less для удобного просмотра.

### Основные команды для использования в конвейерах:
- **grep**: Фильтрация текста по регулярным выражениям.
- **awk**: Обработка и вывод определенных колонок текста.
- **sed**: Потоковый редактор для замены текста.
- **sort**: Сортировка строк.
- **uniq**: Удаление дубликатов в отсортированных строках.
- **wc**: Подсчет строк, слов или символов.
- **head/tail**: Вывод первых или последних строк.

-----

В Linux существует множество символов и специальных обозначений, которые используются в командах и скриптах. Они служат для перенаправления потоков, интерпретации команд, написания скриптов и переменных.

### Описание и примеры:

1. **> (перенаправление вывода)**:
   - Используется для записи вывода команды в файл (перезаписывает содержимое).
   - Пример: `echo "Hello" > file.txt` — записывает строку в файл.

2. **>> (добавление вывода)**:
   - Добавляет вывод команды в конец файла.
   - Пример: `echo "New line" >> file.txt` — добавляет строку в конец файла.

3. **< (перенаправление ввода)**:
   - Передает содержимое файла в качестве ввода для команды.
   - Пример: `wc -l < file.txt` — считает количество строк в файле, используя файл как входной поток.

4. **2> (перенаправление stderr)**:
   - Перенаправляет стандартный поток ошибок в файл.
   - Пример: `command 2> error.log` — записывает ошибки команды в файл.

5. **&> (перенаправление stdout и stderr)**:
   - Перенаправляет как стандартный вывод, так и ошибки в файл.
   - Пример: `command &> output.log` — записывает и стандартный вывод, и ошибки в файл.

6. **#! (shebang)**:
   - Указывает интерпретатор для выполнения скрипта.
   - Пример: `#!/bin/bash` — указывает, что скрипт должен выполняться с помощью bash.

7. **$ (переменные)**:
   - Используется для доступа к значению переменной.
   - Пример: `echo $HOME` — выводит значение переменной окружения HOME.

8. **$(...) (командная подстановка)**:
   - Выполняет команду и подставляет её результат.
   - Пример: `echo $(date)` — выводит текущую дату, выполненную командой `date`.

9. **| (pipe, конвейер)**:
   - Передает вывод одной команды на вход другой.
   - Пример: `ls | grep "txt"` — фильтрует вывод команды `ls`, оставляя только файлы с расширением .txt.

10. **# (комментарий)**:
    - Означает комментарий в скрипте или командной строке.
    - Пример: `# Это комментарий` — строка будет проигнорирована.

11. *** (глобальный шаблон)**:
    - Заменяет любое количество символов в имени файла.
    - Пример: `ls *.txt` — выводит все файлы с расширением .txt.

12. **? (одиночный символ)**:
    - Заменяет один любой символ.
    - Пример: `ls file?.txt` — выводит файлы, где вместо `?` стоит один любой символ.

13. **; (последовательное выполнение)**:
    - Разделяет несколько команд для последовательного выполнения.
    - Пример: `cd /tmp; ls` — переходит в каталог /tmp и выполняет команду `ls`.

14. **&& (логическое И)**:
    - Выполняет следующую команду только если предыдущая завершилась успешно.
    - Пример: `mkdir new_dir && cd new_dir` — создаст директорию и перейдет в неё только в случае успеха.

15. **|| (логическое ИЛИ)**:
    - Выполняет следующую команду, если предыдущая завершилась с ошибкой.
    - Пример: `command || echo "Ошибка"` — выведет сообщение, если команда завершится неудачно.

16. **`...` (устаревшая командная подстановка)**:
    - Выполняет команду и подставляет её результат (альтернатива `$(...)`).
    - Пример: ``echo `date` `` — выводит текущую дату (но лучше использовать `$(...)`).

### Основные команды с этими символами:
- **echo**: выводит текст или переменные.
- **grep**: фильтрует вывод команд.
- **cat**: читает и выводит содержимое файла.
- **ls**: выводит список файлов и директорий.
- **bash**: интерпретирует скрипты с использованием `#!`.

В командной оболочке (например, bash) существуют специальные сокращения и символы для работы с историей команд и их модификации. Вот некоторые из наиболее полезных и часто используемых:

1. **!! (double bang)**:
   - Выполняет последнюю введённую команду.
   - Пример: Если последняя команда была `echo "Hello"`, то `!!` выполнит её снова.

2. **!n**:
   - Выполняет команду под номером `n` из истории.
   - Пример: `!5` выполнит пятую команду из истории команд, которую можно просмотреть с помощью `history`.

3. **!string**:
   - Выполняет последнюю команду, начинающуюся с `string`.
   - Пример: `!git` выполнит последнюю команду, начинающуюся с `git`, например, `git status`.

4. **!$**:
   - Подставляет последний аргумент из предыдущей команды.
   - Пример: Если предыдущая команда была `cat file.txt`, то `echo !$` эквивалентно `echo file.txt`.

5. **!^**:
   - Подставляет первый аргумент предыдущей команды.
   - Пример: Если предыдущая команда была `cp file1.txt file2.txt`, то `echo !^` выведет `file1.txt`.

6. **^old^new**:
   - Замена в последней команде: заменяет слово `old` на `new`.
   - Пример: Если последняя команда была `ls file.tx`, то команда `^tx^txt` исправит ошибку на `ls file.txt`.

7. **!#**:
   - Подставляет текущую команду, ввод которой начат.
   - Полезно для редактирования текущей команды в реальном времени.

8. **!n:p**:
   - Показывает команду с номером `n`, но не выполняет её.
   - Пример: `!5:p` покажет пятую команду из истории без её выполнения.

9. **$_**:
   - Подставляет последний аргумент последней выполненной команды (аналог `!$`).
   - Пример: `echo $_` выведет последний аргумент последней выполненной команды.

10. **Esc + . (или Alt + .)**:
    - Повторяет последний аргумент предыдущей команды.
    - Полезно для быстрого повторения аргументов без необходимости ввода их вручную.

### Пример использования:
1. Вводим команду: `cp file1.txt /tmp/`
2. Вводим `echo !$` — это выведет `/tmp/`, так как это последний аргумент предыдущей команды.
3. Вводим `!cp` — это выполнит последнюю команду, начинающуюся с `cp`, т.е. снова выполнит `cp file1.txt /tmp/`.

Эти сокращения помогают быстро работать с историей команд, редактировать и повторять команды, что значительно ускоряет работу в терминале.


----
#### Твики баша

Для DevOps инженера важно оптимизировать работу в командной оболочке (shell) для повышения эффективности при выполнении рутинных задач. Основные твики оболочки включают настройку переменных окружения, улучшение команд и интеграцию с системами автоматизации.

### Основные твики командной оболочки:

1. **Настройка оболочки (bash/zsh)**:
   - Использование **`~/.bashrc`** или **`~/.zshrc`** для персонализации настроек.
   - Включение **автодополнения** (autocomplete) для ускорения работы с командами и путями:
     ```bash
     # Включение автодополнения для git, kubectl и других инструментов
     source /usr/share/bash-completion/bash_completion
     ```

2. **Создание алиасов (alias)**:
   - Сокращение длинных команд с помощью алиасов:
     ```bash
     alias ll='ls -lah'
     alias gs='git status'
     alias k='kubectl'
     alias dc='docker-compose'
     ```
   - Это позволяет сэкономить время на ввод часто используемых команд.

3. **Использование функций (functions)**:
   - Создание небольших скриптов-функций для часто выполняемых задач:
     ```bash
     function kpod() {
       kubectl get pods --namespace $1
     }
     ```
   - Функции позволяют автоматизировать сложные команды с параметрами.

4. **Переменные окружения**:
   - Настройка переменных для часто используемых путей и настроек:
     ```bash
     export PATH=$PATH:/usr/local/bin
     export KUBECONFIG=~/.kube/config
     ```
   - Переменные среды ускоряют доступ к нужным инструментам и конфигурациям.

5. **Подсветка синтаксиса и информация в командной строке (PS1)**:
   - Настройка **промпта PS1** для отображения информации о пользователе, ветке git и других данных:
     ```bash
     export PS1="\u@\h:\w \$(git_branch)\$ "
     ```
   - Подсветка ветки git помогает не допустить ошибок при работе с репозиториями.

6. **История команд (history)**:
   - Увеличение размера истории команд и удаление дубликатов:
     ```bash
     export HISTSIZE=10000
     export HISTCONTROL=ignoredups:erasedups
     ```
   - Это помогает эффективно использовать историю и искать нужные команды.

7. **Упрощение работы с Docker/Kubernetes**:
   - Настройка автодополнения для **docker** и **kubectl**:
     ```bash
     source <(kubectl completion bash)
     source <(docker completion bash)
     ```
   - Это ускоряет работу с контейнерами и кластером Kubernetes.

8. **Интеграция с **`tmux`**:
   - Использование **tmux** для работы с несколькими сессиями терминала, что позволяет управлять несколькими окнами в одном сеансе.
   - Настройка алиасов для быстрого запуска tmux:
     ```bash
     alias ta='tmux attach -t'
     alias tn='tmux new -s'
     ```

9. **Работа с Git**:
   - Автоматизация работы с git через алиасы и функции:
     ```bash
     alias gpush='git push origin $(git rev-parse --abbrev-ref HEAD)'
     function gcm() {
       git commit -m "$*"
     }
     ```
   - Это помогает ускорить ежедневные операции с кодом.

10. **Инструменты DevOps в shell**:
    - Включение часто используемых DevOps инструментов:
      - **kubectl**: управление Kubernetes кластерами.
      - **helm**: работа с Helm-чартами для деплоя в Kubernetes.
      - **docker** и **docker-compose**: для управления контейнерами.
      - **terraform**: автоматизация инфраструктуры через код.

11. **Использование скриптов для автоматизации**:
    - Автоматизация задач с помощью bash-скриптов:
      ```bash
      # Пример скрипта для автоматического удаления старых Docker контейнеров
      docker ps -a -q | xargs docker rm
      ```

12. **Интеграция с CI/CD**:
    - Использование оболочки для взаимодействия с CI/CD системами:
      ```bash
      alias jcb='jenkins-cli build'
      alias gitlab='gitlab-runner'
      ```

### Основные инструменты для интеграции в shell:
- **Oh My Zsh**: улучшенная оболочка для Zsh с поддержкой плагинов и тем.
- **FZF**: интерактивный инструмент для поиска в истории и файловой системе.
- **Autocompletion**: автодополнение команд для git, kubectl, terraform и других.

Вот еще несколько полезных твиков и приемов для командной оболочки, которые помогут DevOps-инженерам ускорить работу и автоматизировать задачи.

### История и работа с командами:

1. **history | grep <keyword>**:
   - Позволяет искать команды по ключевому слову в истории.
   - Пример: `history | grep docker` — найдет все команды, связанные с `docker`.

2. **Ctrl + r** (reverse search):
   - Поиск по истории команд в интерактивном режиме.
   - Начинайте вводить команду, и оболочка покажет последнюю подходящую команду.

3. **Ctrl + a / Ctrl + e**:
   - **Ctrl + a**: Перемещает курсор в начало строки.
   - **Ctrl + e**: Перемещает курсор в конец строки.

4. **Ctrl + w / Ctrl + u**:
   - **Ctrl + w**: Удаляет слово перед курсором.
   - **Ctrl + u**: Удаляет всё до начала строки.

5. **!!:gs/old/new/**:
   - Замена всех вхождений `old` на `new` в последней команде.
   - Пример: Если последняя команда была `ls file.tx file.tx`, то `!!:gs/tx/txt/` заменит `tx` на `txt` в обеих частях.

6. **pushd / popd**:
   - **pushd**: Сохраняет текущую директорию и перемещается в новую.
   - **popd**: Возвращает в предыдущую сохраненную директорию.
   - Пример: `pushd /var/log` перемещает в `/var/log` и сохраняет предыдущую директорию в стек.

7. **xargs**:
   - Позволяет передавать аргументы командам.
   - Пример: `ls | xargs rm` — удалит все файлы, выведенные командой `ls`.

8. **mktemp**:
   - Создание временных файлов или директорий.
   - Пример: `mktemp` — создаст временный файл. `mktemp -d` — создаст временную директорию.

### Перенаправление потоков:

9. **tee**:
   - Записывает вывод команды в файл и одновременно выводит его в терминал.
   - Пример: `ls | tee file.txt` — выводит результат в терминал и сохраняет его в файл.

10. **2>&1**:
    - Перенаправляет stderr (поток ошибок) в stdout (стандартный вывод).
    - Пример: `command > output.txt 2>&1` — отправляет и ошибки, и стандартный вывод в `output.txt`.

### Обработка файлов и текстов:

11. **sed 's/old/new/g'**:
    - Замена текста в потоке.
    - Пример: `sed 's/error/success/g' file.txt` — заменяет все `error` на `success` в `file.txt`.

12. **awk '{print $1, $3}'**:
    - Извлечение определенных столбцов из текста.
    - Пример: `ls -l | awk '{print $1, $3}'` — выводит первый и третий столбец, например, права и владельца.

13. **cut**:
    - Извлекает части строки по разделителям.
    - Пример: `echo "user:pass" | cut -d ':' -f1` — извлекает `user`.

14. **find / -name "*.log" -delete**:
    - Поиск и удаление файлов по шаблону.
    - Пример: `find /var/log -name "*.log" -delete` — удаляет все лог-файлы в `/var/log`.

15. **truncate -s 0**:
    - Обнуляет файл без удаления.
    - Пример: `truncate -s 0 largefile.log` — очищает содержимое файла `largefile.log`.

### Модификация команд:

16. **!$ (последний аргумент)**:
    - Повторяет последний аргумент предыдущей команды.
    - Пример: `echo "Hello" > file.txt` и затем `cat !$` — откроет `file.txt`.

17. **Ctrl + x + e**:
    - Открывает текущую команду в текстовом редакторе (например, `vim`), что полезно для редактирования длинных команд.

18. **alias**:
    - Создание псевдонимов для часто используемых команд.
    - Пример: `alias ll='ls -lah'` — теперь `ll` будет запускать `ls -lah`.

19. **watch**:
    - Выполняет команду через определенные интервалы времени.
    - Пример: `watch -n 2 df -h` — каждые 2 секунды выводит результат команды `df -h`.

### Работа с файлами и директориями:

20. **du -sh /**:
    - Выводит размер директории.
    - Пример: `du -sh /var` — выводит общий размер директории `/var`.

21. **rsync**:
    - Синхронизация файлов и директорий между системами.
    - Пример: `rsync -avz /source/ user@remote:/destination/` — синхронизирует папку `/source` с удаленной системой.

### Ускорение работы:

22. **Ctrl + l**:
    - Очищает экран терминала.

23. **nohup &**:
    - Выполняет команду в фоновом режиме, даже после выхода из терминала.
    - Пример: `nohup long_task.sh &` — выполнит `long_task.sh` в фоне.

24. **jobs, fg, bg**:
    - Управление фоновыми задачами.
    - **jobs**: показывает список фоновых задач.
    - **fg**: возвращает задачу в передний план.
    - **bg**: отправляет задачу в фоновый режим.

----
#### Архитектура и прочие фундаментальные штуки

1. **Планировщик процессов**:
   - Отвечает за распределение процессорного времени между процессами.
   - Основные состояния процессов: running (работает), sleeping (ожидает ресурс), stopped (остановлен), zombie (завершен, но не удален).
   - Приоритеты процессов определяют, как часто процесс получает доступ к CPU.
   - Команды: `ps`, `top`, `htop`, `nice`, `renice` для управления процессами и приоритетами.

2. **Управление памятью**:
   - Виртуальная память: каждое приложение получает свое виртуальное адресное пространство, которое отображается на физическую память.
   - Swap: используется, когда заканчивается RAM. Менее эффективен по скорости, так как данные перемещаются на диск.
   - Команды: `free` для мониторинга использования памяти, `vmstat` для просмотра статистики использования виртуальной памяти.

3. **Ввод-вывод (I/O) в Linux**:
   - I/O операции: работа с файлами, устройствами и сетевыми интерфейсами.
   - Буферизация: данные временно сохраняются в буфере для повышения эффективности I/O операций.
   - Асинхронный I/O позволяет продолжать выполнение программы, не дожидаясь завершения операций ввода-вывода.
   - Команды: `iostat`, `iotop`, `df` для мониторинга и управления I/O операциями.

7. **Механизмы безопасности**:
   - Контроль доступа: управление правами на уровне файловой системы и процессов.
   - SELinux и AppArmor: механизмы дополнительного контроля доступа к ресурсам системы.
   - Firewall: фильтрация сетевого трафика (iptables, firewalld).
   - Команды: `chmod`, `chown`, `setenforce`, `iptables` для настройки прав и безопасности.

8. **Демоны и системные службы**:
   - Демоны — это фоново работающие процессы (например, SSH, Apache).
   - Системные службы управляются через systemd или SysV init.
   - Команды: `systemctl start/stop`, `service`, `journalctl` для управления службами и просмотра логов.

9. **Управление пакетами**:
   - Менеджеры пакетов устанавливают, обновляют и удаляют ПО (APT для Debian/Ubuntu, YUM/DNF для CentOS/RHEL).
   - Команды: `apt install`, `yum update`, `dnf remove` для работы с пакетами.
   - Компиляция из исходного кода: `./configure`, `make`, `make install`.

10. **Мониторинг и логирование**:
    - Системные логи помогают отслеживать события системы.
    - Команды: `syslog`, `dmesg` (вывод сообщений ядра), `journalctl` (для систем с systemd).
    - Инструменты мониторинга: `htop`, `top`, `iostat` для мониторинга ресурсов системы.

11. **Обработка сигналов и системные вызовы**:
    - Сигналы: механизм взаимодействия с процессами (SIGKILL, SIGTERM).
    - Системные вызовы: интерфейс для взаимодействия между приложениями и ядром (fork, exec).
    - Команды: `kill`, `pkill`, `strace` для отправки сигналов и отслеживания системных вызовов.

12. **Виртуализация**:
    - Виртуализация позволяет запускать несколько виртуальных машин на одном физическом хосте.
    - Инструменты: KVM (виртуализация на уровне ядра), QEMU (эмуляция), libvirt (управление виртуализацией).
    - Команды: `virsh`, `virt-install`, `qemu-img` для управления виртуальными машинами.

13. **Таймеры и планировщики задач**:
    - Планировщики задач автоматизируют выполнение команд по расписанию.
    - Cron: регулярное выполнение задач, atd: выполнение задач в определенное время.
    - Команды: `crontab`, `at`, `systemctl start timer` для настройки таймеров и задач.

14. **Обработка ошибок и управление ресурсами**:
    - Файловые дескрипторы, лимиты ресурсов (ulimit), квоты для пользователей.
    - Команды: `ulimit`, `quota`, `df -i` для управления ресурсами системы и файловыми системами.

15. **Эмуляция терминалов и tty**:
    - tty (teletypewriter) — терминальные устройства для взаимодействия с системой.
    - PTY (псевдотерминалы) — используются для симуляции терминалов (например, SSH).
    - Команды: `tty`, `screen`, `tmux` для управления сессиями терминалов.

16. **Системные вызовы и ядро**:
    - Системные вызовы — это интерфейс для взаимодействия с ядром Linux.
    - Инструменты: `strace` для отслеживания вызовов системы, `lsof` для отображения открытых файлов.
    - Команды: `sysctl`, `uname`, `strace` для управления параметрами ядра и отслеживания системных вызовов.

17. **Разделение прав и пользователей**:
    - Управление пользователями, группами и правами доступа (root, sudo, SUID/SGID).
    - Команды: `useradd`, `usermod`, `passwd`, `sudo` для управления пользователями и правами.

18. **Образы системы и восстановление**:
    - Создание резервных копий и образов системы для быстрого восстановления.
    - Инструменты: `dd`, `rsync`, `tar` для создания и восстановления резервных копий и образов дисков.
    - Команды: `dd if=/dev/sda of=/backup.img`, `rsync -a` для копирования и клонирования.

19. **Журналирование и управление системными ресурсами**:
    - Журналы содержат информацию о работе системы и ошибок.
    - Команды: `journalctl`, `dmesg`, `syslog` для просмотра и анализа журналов.
    - Управление ресурсами: мониторинг использования CPU, памяти, сетевых ресурсов (htop, iostat).

20. **Ресурсы и производительность**:
    - Профилирование системы помогает выявить проблемы с производительностью.
    - Команды: `top`, `htop`, `perf` для мониторинга использования CPU, памяти, I/O.
    - Использование инструментов профилирования и анализа производительности.

21. **Автоматизация через скрипты**:
    - Bash-скрипты позволяют автоматизировать рутинные задачи и конфигурацию.
    - Использование циклов, условий, функций в скриптах.
    - Команды: `bash`, `sh`, `chmod +x script.sh` для выполнения скриптов.

----

**OOM Killer (Out of Memory Killer)** — это механизм в Linux, который активируется, когда системе не хватает оперативной памяти и возможности использования swap. Он завершает один или несколько процессов для освобождения памяти и стабилизации работы системы.

### Как работает OOM Killer:

1. **Когда активируется**:
   - OOM Killer включается, когда ядро Linux обнаруживает, что в системе закончилась свободная память и уже задействован swap, но этого недостаточно для нормальной работы.

2. **Как выбирается процесс для завершения**:
   - Ядро Linux анализирует процессы и выбирает наименее приоритетный для завершения. Каждый процесс оценивается с помощью "OOM score".
   - Процессы с большим потреблением памяти или с низким приоритетом (nice value) могут иметь более высокий "OOM score".
   - Системные процессы (например, сессии root или критически важные демоны) обычно имеют более низкий OOM score, чтобы их не завершали.

3. **Что такое OOM score**:
   - Это показатель, по которому ядро решает, какой процесс убить. Чем выше OOM score, тем больше вероятность, что процесс будет завершен.
   - OOM score можно проверить для каждого процесса:
     ```bash
     cat /proc/<PID>/oom_score
     ```

4. **Как предотвратить завершение процесса OOM Killer**:
   - Можно изменить приоритет процесса для OOM Killer с помощью параметра `oom_adj` или `oom_score_adj`:
     ```bash
     echo -1000 > /proc/<PID>/oom_score_adj
     ```
   - Значение `-1000` исключит процесс из списка потенциальных целей для завершения.

5. **Логирование OOM Killer**:
   - Когда OOM Killer завершает процесс, это записывается в системный лог:
     ```bash
     dmesg | grep -i "killed process"
     ```

### Основные причины, вызывающие OOM Killer:
- Некорректная работа приложения, которое использует слишком много памяти (memory leak).
- Недостаточный объем оперативной памяти для текущих задач системы.
- Неправильная конфигурация системы или приложений, особенно в контейнерах или виртуальных машинах с ограниченными ресурсами.

### Примеры предотвращения:
1. **Настройка swap**: Увеличение объема swap может предотвратить активацию OOM Killer.
2. **Контроль использования памяти**: Используйте инструменты мониторинга (например, `htop`, `free`, `vmstat`) для наблюдения за использованием памяти и заблаговременного выявления проблем.

OOM Killer — это крайняя мера, которая используется для поддержания стабильности системы, когда исчерпаны все другие возможности управления памятью.

----
#### Твикаем ядро

Основные твики ядра Linux, применяемые в DevOps-практиках, нацелены на улучшение производительности, стабильности и безопасности систем, а также на оптимизацию работы с сетью и вводом-выводом. Их настройка осуществляется через интерфейс sysctl или напрямую через параметры загрузки ядра.

### Основные твики ядра и их применение:

1. **fs.file-max** (максимальное количество открытых файлов):
   - **Назначение**: Увеличение лимита на количество одновременно открытых файловых дескрипторов.
   - **Зачем**: Важно для серверов с высокой нагрузкой (веб-серверы, базы данных).
   - **Настройка**:
     ```bash
     sysctl -w fs.file-max=500000
     ```

2. **vm.swappiness** (уровень агрессивности использования swap):
   - **Назначение**: Определяет, как активно система использует swap вместо физической памяти.
   - **Зачем**: Снижение значения уменьшает использование swap, что полезно для систем с большим объемом оперативной памяти, уменьшая задержки.
   - **Настройка**:
     ```bash
     sysctl -w vm.swappiness=10
     ```

3. **net.core.somaxconn** (максимальная длина очереди соединений TCP):
   - **Назначение**: Определяет максимальное количество незавершенных соединений, ожидающих обработки сервером.
   - **Зачем**: Полезно для серверов с высокой сетевой нагрузкой, чтобы избежать отказов при большом количестве входящих соединений.
   - **Настройка**:
     ```bash
     sysctl -w net.core.somaxconn=1024
     ```

4. **net.ipv4.tcp_fin_timeout** (таймаут завершения TCP-соединений):
   - **Назначение**: Устанавливает время, в течение которого система держит закрытое TCP-соединение в состоянии `TIME_WAIT`.
   - **Зачем**: Уменьшение этого значения ускоряет освобождение ресурсов для новых соединений на серверах с интенсивным сетевым трафиком.
   - **Настройка**:
     ```bash
     sysctl -w net.ipv4.tcp_fin_timeout=15
     ```

5. **net.ipv4.tcp_tw_reuse** (повторное использование TCP-соединений в `TIME_WAIT`):
   - **Назначение**: Позволяет повторно использовать соединения в состоянии `TIME_WAIT`.
   - **Зачем**: Ускоряет освобождение соединений на серверах с высокой сетевой нагрузкой.
   - **Настройка**:
     ```bash
     sysctl -w net.ipv4.tcp_tw_reuse=1
     ```

6. **vm.overcommit_memory** (стратегия выделения памяти):
   - **Назначение**: Управляет политикой выделения памяти для приложений, превышающих общий объем доступной памяти.
   - **Зачем**: Полезно для баз данных и приложений с высокими требованиями к памяти. Значение 2 заставляет систему жестко следить за тем, чтобы не выделять больше памяти, чем доступно.
   - **Настройка**:
     ```bash
     sysctl -w vm.overcommit_memory=2
     ```

7. **fs.inotify.max_user_watches** (максимальное количество файлов, которые могут быть отслежены с помощью inotify):
   - **Назначение**: Увеличивает количество файлов, которые могут быть одновременно отслежены.
   - **Зачем**: Важно для систем мониторинга файловых изменений (например, Docker, файловые системы).
   - **Настройка**:
     ```bash
     sysctl -w fs.inotify.max_user_watches=524288
     ```

8. **net.ipv4.ip_local_port_range** (диапазон портов для локальных TCP/UDP соединений):
   - **Назначение**: Определяет диапазон портов, используемых для исходящих соединений.
   - **Зачем**: Полезно для систем с высокой сетевой нагрузкой, чтобы увеличить количество доступных портов для новых соединений.
   - **Настройка**:
     ```bash
     sysctl -w net.ipv4.ip_local_port_range="1024 65535"
     ```

9. **kernel.pid_max** (максимальное количество процессов):
   - **Назначение**: Определяет максимальный допустимый PID, который может быть назначен процессам.
   - **Зачем**: Важно для систем с высокой интенсивностью создания процессов (например, CI/CD серверы, кластерные системы).
   - **Настройка**:
     ```bash
     sysctl -w kernel.pid_max=4194303
     ```

10. **net.ipv4.tcp_rmem / net.ipv4.tcp_wmem** (буферы для чтения и записи TCP):
    - **Назначение**: Определяет минимальный, начальный и максимальный размер буферов для чтения и записи TCP.
    - **Зачем**: Полезно для оптимизации работы с сетевыми приложениями, особенно при высокой нагрузке на сеть.
    - **Настройка**:
      ```bash
      sysctl -w net.ipv4.tcp_rmem="4096 87380 6291456"
      sysctl -w net.ipv4.tcp_wmem="4096 16384 4194304"
      ```

### Как применять твики:
- Изменения можно вносить временно с помощью команды `sysctl`, а для постоянных изменений — прописывать настройки в файле `/etc/sysctl.conf`.
- После изменения настроек можно применить их с помощью:
  ```bash
  sysctl -p ```
  

----
#### Ставим код из сорцов

Чтобы установить приложение из исходных кодов в Linux, обычно используется стандартный процесс: конфигурация, компиляция и установка. Удаление может быть сложнее, так как оно зависит от структуры проекта.

### Установка приложения из исходных кодов:

1. **Установите необходимые зависимости**:
   - Приложению могут понадобиться компиляторы и библиотеки. Например, для сборки C/C++ программ может понадобиться `build-essential`:
     ```bash
     sudo apt install build-essential     # Для Debian/Ubuntu
     sudo yum groupinstall 'Development Tools'  # Для RHEL/CentOS
     ```

2. **Скачайте исходный код**:
   - Обычно скачивается с официального сайта или репозитория:
     ```bash
     wget http://example.com/source-code.tar.gz
     ```

3. **Распакуйте архив**:
   - Распакуйте архив с исходным кодом:
     ```bash
     tar -xvzf source-code.tar.gz
     cd source-code/
     ```

4. **Настройка исходного кода**:
   - Запустите скрипт `configure` для подготовки компиляции:
     ```bash
     ./configure
     ```
   - Опционально можно указать префикс для установки в конкретную директорию:
     ```bash
     ./configure --prefix=/usr/local
     ```

5. **Компиляция программы**:
   - Запустите процесс компиляции:
     ```bash
     make
     ```

6. **Установка программы**:
   - Выполните установку с правами суперпользователя:
     ```bash
     sudo make install
     ```

### Удаление приложения, установленного из исходных кодов:

1. **Удаление с помощью `make uninstall`**:
   - Если в проекте реализован процесс удаления, используйте:
     ```bash
     sudo make uninstall
     ```
   - Не все проекты поддерживают эту команду, и она должна быть описана в Makefile.

2. **Ручное удаление**:
   - Если `make uninstall` не поддерживается, удаление нужно производить вручную.
   - Просмотрите, куда были установлены файлы (обычно `/usr/local/bin`, `/usr/local/lib`, `/usr/local/share`), и удалите их:
     ```bash
     sudo rm /usr/local/bin/program
     sudo rm -r /usr/local/share/program
     ```

3. **Просмотр установки с `checkinstall`** (рекомендуемый способ):
   - Можно использовать `checkinstall` для отслеживания установки:
     ```bash
     sudo apt install checkinstall   # Для Debian/Ubuntu
     sudo yum install checkinstall   # Для RHEL/CentOS
     ```
   - Вместо `make install`, запустите:
     ```bash
     sudo checkinstall
     ```
   - Это создаст пакет, который можно будет потом удалить через менеджер пакетов:
     ```bash
     sudo dpkg -r program   # Для Debian/Ubuntu
     sudo rpm -e program     # Для RHEL/CentOS
     ```

### Примечания:
- Использование `checkinstall` упрощает удаление программ.
- Если удаляете вручную, важно помнить, какие файлы были установлены, чтобы корректно их удалить.



